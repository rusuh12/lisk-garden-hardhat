{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-75c63bcde6d54657f01d9fe12ee6af4de07ccbb3",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/LiskGarden.sol": "project/contracts/LiskGarden.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/LiskGarden.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ncontract LiskGarden {\n    // Enums\n    enum GrowthStage { SEED, SPROUT, GROWING, BLOOMING }\n\n    // Structs\n    struct Plant {\n        uint256 id;\n        address owner;\n        GrowthStage stage;\n        uint256 plantedDate;\n        uint256 lastWatered;\n        uint8 waterLevel;\n        bool exists;\n        bool isDead;\n    }\n\n    // State variables\n    mapping(uint256 => Plant) public plants;\n    mapping(address => uint256[]) public userPlants;\n    uint256 public plantCounter;\n    address public owner;\n\n    // Constants\n    uint256 public constant PLANT_PRICE = 0.001 ether;\n    uint256 public constant HARVEST_REWARD = 0.003 ether;\n    uint256 public constant STAGE_DURATION = 1 minutes;\n    uint256 public constant WATER_DEPLETION_TIME = 30 seconds;\n    uint8 public constant WATER_DEPLETION_RATE = 2;\n\n    // Events\n    event PlantSeeded(address indexed owner, uint256 indexed plantId);\n    event PlantWatered(uint256 indexed plantId, uint8 newWaterLevel);\n    event PlantHarvested(uint256 indexed plantId, address indexed owner, uint256 reward);\n    event StageAdvanced(uint256 indexed plantId, GrowthStage newStage);\n    event PlantDied(uint256 indexed plantId);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Plant a seed\n    function plantSeed() external payable returns (uint256) {\n        require(msg.value >= PLANT_PRICE, \"Need 0.001 ETH to plant\");\n\n        plantCounter++;\n        uint256 newPlantId = plantCounter;\n\n        plants[newPlantId] = Plant({\n            id: newPlantId,\n            owner: msg.sender,\n            stage: GrowthStage.SEED,\n            plantedDate: block.timestamp,\n            lastWatered: block.timestamp,\n            waterLevel: 100,\n            exists: true,\n            isDead: false\n        });\n\n        userPlants[msg.sender].push(newPlantId);\n\n        emit PlantSeeded(msg.sender, newPlantId);\n\n        return newPlantId;\n    }\n\n    // Calculate current water level\n    function calculateWaterLevel(uint256 plantId) public view returns (uint8) {\n        Plant storage plant = plants[plantId];\n\n        if (!plant.exists || plant.isDead) {\n            return 0;\n        }\n\n        uint256 timeSinceWatered = block.timestamp - plant.lastWatered;\n        uint256 depletionIntervals = timeSinceWatered / WATER_DEPLETION_TIME;\n\n        uint256 waterLost = depletionIntervals * WATER_DEPLETION_RATE;\n\n        if (waterLost >= plant.waterLevel) {\n            return 0;\n        }\n\n        return plant.waterLevel - uint8(waterLost);\n    }\n\n    // Update water level and check if plant died\n    function updateWaterLevel(uint256 plantId) internal {\n        Plant storage plant = plants[plantId];\n\n        uint8 currentWater = calculateWaterLevel(plantId);\n        plant.waterLevel = currentWater;\n\n        if (currentWater == 0 && !plant.isDead) {\n            plant.isDead = true;\n            emit PlantDied(plantId);\n        }\n    }\n\n    // Water a plant\n    function waterPlant(uint256 plantId) external {\n        Plant storage plant = plants[plantId];\n        require(plant.exists, \"Plant doesn't exist\");\n        require(plant.owner == msg.sender, \"Not your plant\");\n        require(!plant.isDead, \"Plant is dead\");\n\n        plant.waterLevel = 100;\n        plant.lastWatered = block.timestamp;\n\n        emit PlantWatered(plantId, 100);\n\n        updatePlantStage(plantId);\n    }\n\n    // Update plant stage based on time\n    function updatePlantStage(uint256 plantId) public {\n        Plant storage plant = plants[plantId];\n        require(plant.exists, \"Plant doesn't exist\");\n\n        // Update water level first\n        updateWaterLevel(plantId);\n\n        // Dead plants can't grow\n        if (plant.isDead) {\n            return;\n        }\n\n        uint256 timeSincePlanted = block.timestamp - plant.plantedDate;\n        GrowthStage oldStage = plant.stage;\n\n        if (timeSincePlanted >= STAGE_DURATION && plant.stage == GrowthStage.SEED) {\n            plant.stage = GrowthStage.SPROUT;\n        }\n        else if (timeSincePlanted >= 2 * STAGE_DURATION && plant.stage == GrowthStage.SPROUT) {\n            plant.stage = GrowthStage.GROWING;\n        }\n        else if (timeSincePlanted >= 3 * STAGE_DURATION && plant.stage == GrowthStage.GROWING) {\n            plant.stage = GrowthStage.BLOOMING;\n        }\n\n        if (plant.stage != oldStage) {\n            emit StageAdvanced(plantId, plant.stage);\n        }\n    }\n\n    // Harvest a blooming plant\n    function harvestPlant(uint256 plantId) external {\n        Plant storage plant = plants[plantId];\n        require(plant.exists, \"Plant doesn't exist\");\n        require(plant.owner == msg.sender, \"Not your plant\");\n        require(!plant.isDead, \"Plant is dead\");\n\n        updatePlantStage(plantId);\n\n        require(plant.stage == GrowthStage.BLOOMING, \"Plant not ready\");\n\n        plant.exists = false;\n\n        emit PlantHarvested(plantId, msg.sender, HARVEST_REWARD);\n\n        (bool success, ) = msg.sender.call{value: HARVEST_REWARD}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    // Get plant info with current water level\n    function getPlant(uint256 plantId) external view returns (Plant memory) {\n        Plant memory plant = plants[plantId];\n        plant.waterLevel = calculateWaterLevel(plantId);\n        return plant;\n    }\n\n    // Get user's plants\n    function getUserPlants(address user) external view returns (uint256[] memory) {\n        return userPlants[user];\n    }\n\n    // Owner can withdraw contract balance\n    function withdraw() external {\n        require(msg.sender == owner, \"Not owner\");\n        (bool success, ) = owner.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    // Receive ETH\n    receive() external payable {}\n}"
      }
    }
  }
}